diff --git a/projects/neurodaemon/CMakeLists.txt b/projects/neurodaemon/CMakeLists.txt
index 805a652..3ccde86 100644
--- a/projects/neurodaemon/CMakeLists.txt
+++ b/projects/neurodaemon/CMakeLists.txt
@@ -2,6 +2,13 @@ project(neurodaemon)
 
 set(NEURODAEMON_SRC_FILES
     src/main.cpp
+    ../../include/base64_lib/base64.hpp
+    ../../include/thread_pool/thread_pool.hpp
+    ../../libsrc/thread_pool/thread_pool.cpp
+    ../../include/server/client_handler.hpp
+    ../../libsrc/server/client_handler.cpp
+    ../../include/server/server.hpp
+    ../../libsrc/server/server.cpp
 )
 
 SET(NEURODAEMON_NAME ${PROJECT_NAME})
@@ -9,3 +16,5 @@ add_executable(${NEURODAEMON_NAME} ${NEURODAEMON_SRC_FILES})
 
 target_include_directories(${NEURODAEMON_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/include)
 target_link_libraries(${NEURODAEMON_NAME} PRIVATE text_process_lib protogen)
+
+target_compile_options(${NEURODAEMON_NAME} PRIVATE "-g")
\ No newline at end of file
diff --git a/projects/neurodaemon/src/base64.hpp b/projects/neurodaemon/src/base64.hpp
deleted file mode 100644
index 1ed67dc..0000000
--- a/projects/neurodaemon/src/base64.hpp
+++ /dev/null
@@ -1,100 +0,0 @@
-#ifndef BASE_64_HPP
-#define BASE_64_HPP
-
-#include <algorithm>
-#include <stdexcept>
-#include <string>
-#include <string_view>
-
-namespace base64 {
-
-inline constexpr std::string_view base64_chars{"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-                                               "abcdefghijklmnopqrstuvwxyz"
-                                               "0123456789+/"};
-
-template<class OutputBuffer, class InputIterator>
-inline OutputBuffer encode_into(InputIterator begin, InputIterator end) {
-	static_assert(std::is_same_v<std::decay_t<decltype(*begin)>, char>
-		|| std::is_same_v<std::decay_t<decltype(*begin)>, unsigned char>
-		|| std::is_same_v<std::decay_t<decltype(*begin)>, std::byte>);
-
-  size_t counter = 0;
-  uint32_t bit_stream = 0;
-  size_t offset = 0;
-  OutputBuffer encoded;
-	encoded.reserve(static_cast<size_t>(1.5 * static_cast<double>(std::distance(begin, end))));
-  while(begin != end) {
-		auto const num_val = static_cast<unsigned char>(*begin);
-    offset = 16 - counter % 3 * 8;
-    bit_stream += num_val << offset;
-    if (offset == 16) {
-      encoded.push_back(base64_chars[bit_stream >> 18 & 0x3f]);
-    }
-    if (offset == 8) {
-      encoded.push_back(base64_chars[bit_stream >> 12 & 0x3f]);
-    }
-    if (offset == 0 && counter != 3) {
-      encoded.push_back(base64_chars[bit_stream >> 6 & 0x3f]);
-      encoded.push_back(base64_chars[bit_stream & 0x3f]);
-      bit_stream = 0;
-    }
-    ++counter;
-		++begin;
-  }
-  if (offset == 16) {
-    encoded.push_back(base64_chars[bit_stream >> 12 & 0x3f]);
-    encoded.push_back('=');
-		encoded.push_back('=');
-  }
-  if (offset == 8) {
-    encoded.push_back(base64_chars[bit_stream >> 6 & 0x3f]);
-		encoded.push_back('=');
-  }
-  return encoded;
-}
-
-inline std::string to_base64(std::string_view data) {
-	return encode_into<std::string>(std::begin(data), std::end(data));
-}
-
-template<class OutputBuffer>
-inline OutputBuffer decode_into(std::string_view data) {
-	using value_type = typename OutputBuffer::value_type;
-	static_assert(std::is_same_v<value_type, char>
-		|| std::is_same_v<value_type, unsigned char>
-		|| std::is_same_v<value_type, std::byte>);
-
-  size_t counter = 0;
-  uint32_t bit_stream = 0;
-  OutputBuffer decoded;
-	decoded.reserve(std::size(data));
-  for (unsigned char c : data) {
-    auto const num_val = base64_chars.find(c);
-    if (num_val != std::string::npos) {
-      auto const offset = 18 - counter % 4 * 6;
-      bit_stream += static_cast<uint32_t>(num_val) << offset;
-      if (offset == 12) {
-        decoded.push_back(static_cast<value_type>(bit_stream >> 16 & 0xff));
-      }
-      if (offset == 6) {
-        decoded.push_back(static_cast<value_type>(bit_stream >> 8 & 0xff));
-      }
-      if (offset == 0 && counter != 4) {
-        decoded.push_back(static_cast<value_type>(bit_stream & 0xff));
-        bit_stream = 0;
-      }
-    } else if (c != '=') {
-      throw std::runtime_error{"Invalid base64 encoded data"};
-    }
-    counter++;
-  }
-  return decoded;
-}
-
-inline std::string from_base64(std::string_view data) {
-	return decode_into<std::string>(data);
-}
-
-} // namespace base64
-
-#endif // BASE_64_HPP
\ No newline at end of file
diff --git a/projects/neurodaemon/src/main.cpp b/projects/neurodaemon/src/main.cpp
index c83f031..5cc5434 100644
--- a/projects/neurodaemon/src/main.cpp
+++ b/projects/neurodaemon/src/main.cpp
@@ -1,139 +1,97 @@
-#include "text_process/neuro_predict.hpp"
-#include "protogen/neuro.pb.h"
-#include <iostream>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <unistd.h>
-#include <cstring>
-#include "base64.hpp"
+#include <signal.h>
+#include<unistd.h>   
+#include "thread_pool/thread_pool.hpp"
+#include "server/client_handler.hpp"
+#include "server/server.hpp"
 
 
-class ClientHandler {
-    public:
-        const int PORT = 12345;
-        const int MAX_BUFFER_SIZE = 1024;
-        int client_socket;
-        struct sockaddr_in client_addr;
-        socklen_t client_addr_len = sizeof(client_addr);
-        
-        std::string_view tokenizer_path{"/home/coma/cpp_ext/cpp_mt_neurodaemon/data/e5/sentencepiece.bpe.model"}; 
-        std::string_view weights_path{"/home/coma/cpp_ext/cpp_mt_neurodaemon/data/e5/traced_e5.pt"}; 
-        text_process::TextEmbedder emb{tokenizer_path, weights_path};
+volatile bool shouldExit = false;
 
-        std::vector<float> get_embeddings(std::string_view str_to_encode) {
-            return emb.Encode(str_to_encode);
-        }
-
-        int accept_connection(int server_socket) {
-            client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_addr_len);
-            return client_socket;
-        }
+void signalHandler(int signal) {
+    std::cout << "Ctrl+C pressed!" << std::endl;
+    exit(0);
+}
 
-        std::string receive_data() {
-            char buffer[MAX_BUFFER_SIZE];
-            ssize_t bytes_received;
+int main(int argc, char *argv[]) {
+    signal(SIGINT, signalHandler);
 
-            std::string received_data;
-            std::string decoded_str;
+    if (argc < 2) {
+        std::cerr << "Usage: " << argv[0] << " <mode> \n mode: \n - 's' single thread \n - 'm' multithread" << std::endl;
+        std::cerr << "- 't <n_min> <n_max> k' thread pool with threads count n_min (default value 4) \n\t n_max high watermark value (optional, must be greater than n_min) \n" << std::endl;
+        std::cerr << "\t k -keepalive mode (optional, default false)" << std::endl;
+        std::cerr << "\t m -max tasks for threadpool (optional, default 1024)" << std::endl;
+        return 1; // indicate error
+    }
+    char mode = argv[1][0];
+    if (mode != 's' && mode != 'm' && mode != 't') {
+        std::cerr << "Usage: " << argv[0] << " <mode> \n mode: \n - 's' single thread \n - 'm' multithread" << std::endl;
+        std::cerr << "- 't <n_min> <n_max> k' thread pool with threads count n_min (default value 4) \n\t n_max high watermark value (optional, must be greater than n_min) \n" << std::endl;
+        std::cerr << "\t k -keepalive mode (optional, default false)" << std::endl;
+        std::cerr << "\t m -max tasks for threadpool (optional, default 1024)" << std::endl;
+        return 1; // indicate error
+    }
 
-            while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
-                received_data.append(buffer, bytes_received);
-                if (received_data.find('\n') != std::string::npos) {
-                    break;
+    int server_mode;
+    bool keepalive_mode = false;
+    int threads_min = 0;
+    int threads_max = 0;
+    int max_tasks = 1024;
+    switch(mode) {
+        case 's':
+            server_mode = 1;
+            break;
+        case 'm':
+            server_mode = 2;
+            break;
+        case 't': {
+            server_mode = 3;
+            if (argc < 3) {
+                std::cout << "threads number for pool not specified, using default 4\n";
+                threads_min = 4;
+                threads_max = threads_min;
+            } else {
+                threads_min = std::stoi(argv[2]);
+                threads_max = threads_min;
+                if (argc > 3) {
+                    if (strcmp(argv[3], "m") == 0) {
+                        if (argc > 4) {
+                            max_tasks = std::stoi(argv[4]);
+                            if (argc > 5 && (strcmp(argv[5], "k") == 0)) {
+                                keepalive_mode = true;
+                            }
+                        } else {
+                            std::cerr << "max tasks not setted\n";
+                            return 1;
+                        }
+                    } else if (strcmp(argv[3], "k") == 0) {
+                        keepalive_mode = true;
+                    } else {
+                        threads_max = std::stoi(argv[3]);
+                        if (threads_max < threads_min) {
+                            std::cerr << "n_max should be greater than n_min\n";
+                            return 1;
+                        }
+                        if (argc > 4 && strcmp(argv[4], "k") == 0) {
+                            keepalive_mode = true;
+                        }
+                    }
                 }
             }
 
-            // Check for correct termination
-            if (bytes_received <= 0 || received_data.back() != '\n') {
-                std::cerr << "Error receiving data from client" << std::endl;
-                close(client_socket);
-                return decoded_str;
-            }
-
-            received_data.pop_back();
-
-            // Decode Base64
-            decoded_str = base64::from_base64(received_data);
-
-            return decoded_str;
-        }
-        
-        std::string generate_responce_protobuf(std::string decoded_str){
-            text_process::NeuroRequest request;
-            text_process::NeuroAnswer response;
-            // Parse NeuroRequest
-            request.ParseFromString(decoded_str);
-            std::vector<float> embeddings = get_embeddings(request.query());
-
-            response.set_qid(request.qid());
-
-            for (float value : embeddings) {
-                response.add_embedding(value);
-            }
-            response.set_error(" ");
-
-            std::string response_str;
-            response.SerializeToString(&response_str);
-
-            return response_str;
-        }
-
-        int send_protobuf(std::string protobuf_str){
-            std::string base64_response = base64::to_base64(protobuf_str);
-            send(client_socket, base64_response.c_str(), base64_response.size(), 0);
-            return 0;
-        }
-    
-        int handle_client(int server_socket) {
-            accept_connection(server_socket);
-            std::string decoded_req = receive_data();
-            std::string protobuf_resp = generate_responce_protobuf(decoded_req);
-            send_protobuf(protobuf_resp);
-            shutdown(client_socket, SHUT_RD);
-            close(client_socket);
-            return 0;
-        }
-};
-
-
-int main() {
-    const int PORT = 12345;
-    int server_socket;
-    struct sockaddr_in server_addr;
-    ClientHandler client_handler;
-
-    // Create socket
-    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
-        perror("Error creating socket");
-        return 1;
+        } break;
+        default:
+            server_mode = 1;
+            break;
     }
 
-    // Configure server address
-    server_addr.sin_family = AF_INET;
-    server_addr.sin_port = htons(PORT);
-    server_addr.sin_addr.s_addr = INADDR_ANY;
-
-    // Bind socket
-    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
-        perror("Error binding socket");
-        return 1;
-    }
-
-    // Listen for incoming connections
-    if (listen(server_socket, 10) == -1) {
-        perror("Error listening for connections");
-        return 1;
-    }
+    Server server = Server(server_mode, max_tasks, keepalive_mode);
 
-    std::cout << "Server listening on port " << PORT << std::endl;
+    server.bind_socket();
+    server.start_processing(threads_min, threads_max);
 
-    std::cout << "Start handling iteration" << std::endl;
     while (true) {
-        client_handler.handle_client(server_socket);
+        sleep(1);
     }
-    std::cout << "End of handler" << std::endl;
-    close(server_socket);
 
     return 0;
 }
diff --git a/projects/protogen/etc/neuro.proto b/projects/protogen/etc/neuro.proto
index 2a7ebce..719902c 100644
--- a/projects/protogen/etc/neuro.proto
+++ b/projects/protogen/etc/neuro.proto
@@ -11,7 +11,6 @@ message NeuroRequest
 message NeuroAnswer
 {
     uint32 qid               = 1; // Соответствует NeuroRequest::qid
-
     repeated float embedding = 2;
     string error             = 3; // Заполняется, если произошла ошибка (embedding тогда пустой)
 }
diff --git a/projects/tcp_load/obf_tcp_load_v1.2.py b/projects/tcp_load/obf_tcp_load_v1.2.py
old mode 100644
new mode 100755
index 57d4955..ca17a3b
--- a/projects/tcp_load/obf_tcp_load_v1.2.py
+++ b/projects/tcp_load/obf_tcp_load_v1.2.py
@@ -4,7 +4,7 @@
 # Считает, что запрос - 1 строка, и сервер понимает \n как разделитель
 # Аналогично, ответы делит тоже по \n
 
-Z='INFO'
+Z='DEBUG'
 Y=False
 X='store_true'
 W=Exception
@@ -24,7 +24,7 @@ C.add_argument('--parallel',type=N,default=A,help='Count of threads for loading'
 C.add_argument('--timeout',type=N,default=A,help='Timeout of w+r operations')
 C.add_argument('--keepalive',action=X,default=A,help='Do drop connection in client')
 C.add_argument('--infinite',default=Y,action=X,help='Make an infinite cycle from input file')
-C.add_argument('--loglevel',default=Z,choices=['DEBUG',Z,'WARNING','ERROR','CRITICAL'],help='Set the logging level')
+C.add_argument('--loglevel',default=Z,choices=[Z,'INFO','WARNING','ERROR','CRITICAL'],help='Set the logging level')
 C.add_argument('input_file',type=str,help='File with queries, line by line')
 B=C.parse_args()
 if B.rate is not A and B.parallel is not A:raise Q('Cannot specify --rate and --parallel simultaniously!')
@@ -47,7 +47,16 @@ H=0
 M=0
 D=[]
 G=dict()
-async def d(reader,writer,q,q_num):B=b'\n';A=writer;A.write(q.encode('utf-8')+B);await A.drain();D=1024;C=await reader.readuntil(B);return C
+
+async def d(reader,writer,q,q_num):
+	B=b'\n'
+	A=writer
+	A.write(q.encode('utf-8')+B)
+	await A.drain()
+	D=1024
+	C=await reader.readline()
+	return C
+
 async def e(clid):
 	global H,M;C,P=A,A
 	for(J,Q)in c:
@@ -60,7 +69,9 @@ async def e(clid):
 			except W as K:F.error(f"{J}: Error open connection: {K}");H+=1;continue
 		try:
 			if B.keepalive:R=E.datetime.now()
-			S=await L.wait_for(d(P,C,Q,J),B.timeout);D.append((E.datetime.now()-R).total_seconds()*1000);F.info(f"{J}: Success in {D[-1]} ms, data = {S}")
+			S=await L.wait_for(d(P,C,Q,J),B.timeout)
+			D.append((E.datetime.now()-R).total_seconds()*1000)
+			F.info(f"{J}: Success in {D[-1]} ms")
 		except TimeoutError as K:F.warning(f"{J}: Timeout: {K}");M+=1
 		except W as K:F.error(f"{J}: Error during i/o: {K}");H+=1
 	if C is not A:
diff --git a/scripts/simple_load/client.py b/scripts/simple_load/client.py
index 0f555f1..4754feb 100644
--- a/scripts/simple_load/client.py
+++ b/scripts/simple_load/client.py
@@ -56,6 +56,7 @@ def calculate_stistics(response_times, errors_c):
     print(f"rps = {rps}")
     print(f"errors_count = {errors_c}")
 
+
 def main():
     host = "localhost"
     port = 12345
@@ -64,20 +65,22 @@ def main():
     errors_c = 0
 
     try:
-        file = open("text_data.txt", "r")
+        # file = open("text_data.txt", "r")
+        file = open("pb_data.txt", "r")
         line = file.readline()
         while line:
             c += 1
             try:
-                b64_line = encode_data(c, line) + b"\n"
+                # b64_line = encode_data(c, line) + b"\n"
                 with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                     start = timer()
                     s.connect((host, port))
-                    s.sendall(b64_line)
+                    # s.sendall(b64_line)
+                    s.sendall(line.encode("utf-8"))
                     response = fetch_data(s)
                     response_times.append(timedelta(seconds=timer()-start))
                     decodet_data = decode_data(response)
-                    print(c)
+                    print(line)
             except socket.timeout:
                 errors_c += 1    
             finally:
